import numpy as np
import dipy.reconst.dti as dti
import dipy.core.geometry as geo

def l2norm(vector):
    """
    Normalize a vector to be unit length

    Parameters
    ----------
    vector : 1d array

    Returns
    -------
    The vector, normalized by its norm    
    """
    return vector / np.dot(vector, vector)
    

def canonical_tensor(evecs, evals, bvec, bval=1, S0=1):
    """
    The signal generated by a tensor

    Parameters
    ----------
    evecs : 3 by 3 array
    evals : array of 3 elements
    bvec : 3-element unit vector
    bval : float
        The b-value used for the measurement
    S0 : float
        The baseline signal    
    """ 
    R = np.asarray(evecs)
    D = np.dot(np.dot(R, np.diag(evals)), R.T)
    return S0 * np.exp(-bval * np.dot(np.dot(bvec, D), bvec.T))


def kernel_signal(in_dir, out_dir, evals=np.array([1.5, 0.5, 0.5]), bval=1):
    """
    The signal generated by a canonical tensor with a PDD at out_dir in
    direction in_dir
    
    """
    # Rotate the canonical tensor towards the output direction and  
    # calculate the signal you would have gotten in the direction
    evals = np.asarray(evals)
    canon_tensor = np.array([[evals[0], 0, 0], [0, evals[1], 0], [0, 0, evals[2]]])
    rot_matrix = geo.vec2vec_rotmat(np.array([1,0,0]), out_dir)
    out_tensor = np.dot(rot_matrix, canon_tensor)
    _, evecs = dti.decompose_tensor(out_tensor)
    s = canonical_tensor(evecs, evals, in_dir, bval=bval, S0=1)    
    return s


def distance_weight(dist, tau=1):
    return np.exp(-dist/tau)


def weighting(location, out_dir, in_dir):
    norm_location = l2norm(location)
    out_corr = np.dot(norm_location, out_dir) 
    in_corr = np.dot(norm_location, in_dir)
    return distance_weight(np.dot(location, location)) * out_corr * in_corr


def design_signal(location, in_dir, out_dir, evals=np.array([1.5, 0.5, 0.5]),
                  bval=1):

    """
    location : the center-to-center location (relative to 0,0,0)
    
    in_dir : observations
    out_dir : parameters
    
    """ 
    this_signal = kernel_signal(in_dir, out_dir, evals=evals, bval=bval)
    # If you are at the center location:
    if np.all(location == np.array([0, 0, 0])):
        return this_signal
    # Otherwise, we need to downweight by distance and angle 
    else:
        return weighting(location, out_dir, in_dir) * this_signal 
